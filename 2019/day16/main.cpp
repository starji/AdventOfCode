#include <iostream>
#include <locale>
#include <map>
#include <iterator>
#include <cctype>
#include <algorithm>
#include <cstdlib>
#include <set>
#include <cmath>
#include <cstdint>
#include <limits>
#include <stack>
#include <fstream>
#include <numeric>

#include "Advent.hpp"
#include "Intcode.hpp"

#if 0
int generateElement(int index, const std::vector<int>& input)
{
    constexpr std::array<int, 4> base_pattern {0, 1, 0, -1};

    auto element = index + 1;

    std::cout << "Element: " << element << std::endl;

    auto l = std::lcm(input.size(), base_pattern.size() * element);
    auto m = (10000 * input.size()) / l;
    auto r = (10000 * input.size()) % l;

    std::cout << "LCM: " << l << " Mult: " << m << " Remainder: " << r << std::endl;

    int result = 0;
    for(auto i = 0; i < l; ++i)
    {
        result += input[(i % input.size())] *
            base_pattern[((i+1)/element) % 4];
    }

    result *= m;

    // Add in the leftover elements that would normally be excluded.
    for(auto i = 0; i < r; ++i)
    {
        result += input[(i % input.size())] *
            base_pattern[((i+1)/element) % 4];
    }

    return abs(result) % 10;
}

std::vector<int> fft(std::vector<int> input)
{
    std::vector<int> result;
    result.resize(input.size());
    // each element in the new list is generated by multiplying
    //  every value in the input list by a repeating pattern.

    // this pattern is different per element
    for(auto i = 0; i < input.size(); ++i)
    {
        result[i] = generateElement(i, input);
    }

    return result;
}
#endif

int generateElement(int index, const std::vector<int> input)
{
    constexpr std::array<int, 4> base_pattern {0, 1, 0, -1};
    int result = 0;
    auto i = index;
    auto element = index + 1;
    while(i < input.size())
    {
        auto factor = base_pattern[((i+1)/element)%4];
        if(factor != 0)
        {
            int partial = 0;
            for(auto j = i; j < i + element && j < input.size(); ++j)
            {
                partial += input[j];
            }
            result += (partial * factor);
        }
        i += element;
    }
    return std::abs(result) % 10;
}

std::vector<int> partialFFT(int index, std::vector<int> input)
{
    std::vector<int> result (input.size());
    for(auto i = index; i < input.size(); ++i)
    {
        result[i] = generateElement(i, input);
    }
    return result;
}

void print(int length, const std::vector<int>& values)
{
    for(auto i = 0; i < length; ++i)
    {
        std::cout << values[i];
    }
    std::cout << std::endl;
}

int main(int argc, char* argv[])
{
    auto input = std::ifstream("input.txt");
    input.imbue(std::locale(input.getloc(), new Advent::ctype));

    std::vector<int> raw_values;

    auto input_iter = std::istream_iterator<char>{ input };
    while(input_iter != std::istream_iterator<char>{})
    {
        raw_values.push_back((*input_iter) - 48);
        ++input_iter;
    }

    // std::vector<int> raw_values { 0,3,0,3,6,7,3,2,5,7,7,2,1,2,9,4,4,0,6,3,4,9,1,5,6,5,4,7,4,6,6,4 };
    // std::vector<int> full_values;
    // for(auto i = 0; i < 10000; ++i)
    // {
    //     std::copy(raw_values.begin(), raw_values.end(), std::back_inserter(full_values));
    // }
    
    std::cout << std::endl;

//    auto offset = 5979067;

    std::vector<int> values;
    for(auto i = 5979067; i < 10000 * raw_values.size(); ++i)
    {
        values.push_back(raw_values[i % raw_values.size()]);
    }

    std::cout << "Beginning calculations: size=" << values.size() << std::endl;

    for(auto i = 0; i  < 100; ++i)
    {
        std::vector<int> partial_sums;
        std::partial_sum(values.rbegin(), values.rend(), std::back_inserter(partial_sums));
        std::transform(partial_sums.rbegin(), partial_sums.rend(), values.begin(),
                       [](auto v)
                       {
                           return v % 10;
                       });
    }

    std::cout << "hackyfft complete" << std::endl;

    print(8, values);

    std::cout << std::endl;

    // FFT

    // Takes a list of numbers

    // for each phase
    // for(auto i = 0; i < 100; ++i)
    // {
    //     values = fft(values);
    //     print(8, values);
    // }
    

    return 0;
}
